## 例子

如果从

```jsx
<div>
  <p>我是p标签</p>
  <span>我是span标签</span>
</div>
```

更新到

```jsx
<div>
  <p>我是p标签</p>
  <div>我是span标签</div>
  <h1>我是h1标签</h1>
</div>
```

这个状态，整体的更新流程在下面用mermaid进行展示

## 更新分析

### 变化总结

1. **div根节点**：保持不变，可以复用
2. **p标签**：内容和位置都没变，可以复用
3. **span标签**：类型从span变为div，需要替换
4. **h1标签**：新增的节点

### 1. Fiber树结构对比图

#### 更新前的Fiber树结构

```mermaid
flowchart TD
    A["HostRoot"] --> B["div Fiber"]
    B --> C["p Fiber"]
    B --> D["span Fiber"]
    C --> E["'我是p标签' TextNode"]
    D --> F["'我是span标签' TextNode"]

    C -.sibling.-> D

    style A fill:#e3f2fd,color:#000000
    style B fill:#fff3e0,color:#000000
    style C fill:#e8f5e8,color:#000000
    style D fill:#ffebee
    style E fill:#f3e5f5,color:#000000
    style F fill:#f3e5f5,color:#000000
```

#### 更新后的Fiber树结构

```mermaid
flowchart TD
    A["HostRoot"] --> B["div Fiber"]
    B --> C["p Fiber"]
    B --> G["div Fiber (新)"]
    B --> H["h1 Fiber (新)"]
    C --> E["'我是p标签' TextNode"]
    G --> I["'我是span标签' TextNode"]
    H --> J["'我是h1标签' TextNode (新)"]

    C -.sibling.-> G
    G -.sibling.-> H

    style A fill:#e3f2fd,color:#000000
    style B fill:#fff3e0,color:#000000
    style C fill:#e8f5e8,color:#000000
    style G fill:#c8e6c9,color:#000000
    style H fill:#c8e6c9,color:#000000
    style E fill:#f3e5f5,color:#000000
    style I fill:#f3e5f5,color:#000000
    style J fill:#c8e6c9,color:#000000
```

### 2. 详细的Reconciliation过程流程图

```mermaid
flowchart TD
    A["开始更新 updateContainer"] --> B["创建Update对象"]
    B --> C["enqueueUpdate到根节点"]
    C --> D["schedultUpdateOnFiber"]
    D --> E["renderRoot开始"]
    E --> F["prepareFreshStack创建workInProgress树"]

    F --> G["开始workLoop"]
    G --> H["performUnitOfWork(HostRoot)"]
    H --> I["beginWork(HostRoot)"]
    I --> J["处理根节点的更新队列"]
    J --> K["返回div子节点"]

    K --> L["performUnitOfWork(div)"]
    L --> M["beginWork(div)"]
    M --> N["对比新旧children"]
    N --> O["reconcileChildren"]

    O --> P["第一个子节点: p标签"]
    P --> Q{"p标签可复用?"}
    Q -->|是| R["复用现有p Fiber"]
    Q -->|否| S["创建新p Fiber"]

    R --> T["第二个子节点: div标签"]
    S --> T
    T --> U{"对应位置是span?"}
    U -->|是| V["类型不匹配，标记删除span"]
    V --> W["创建新div Fiber"]

    W --> X["第三个子节点: h1标签"]
    X --> Y["创建新h1 Fiber"]

    Y --> Z["返回第一个子节点p"]
    Z --> AA["继续处理子节点..."]

    style A fill:#e3f2fd,color:#000000
    style V fill:#ffcdd2
    style W fill:#c8e6c9,color:#000000
    style Y fill:#c8e6c9,color:#000000
```

### 3. 节点操作流程图

```mermaid
flowchart TD
    A["开始reconcileChildren"] --> B["获取新的children数组"]
    B --> C["[p元素, div元素, h1元素]"]
    C --> D["获取旧的第一个子节点"]
    D --> E["oldFiber = current.child (p)"]

    E --> F["遍历新children"]
    F --> G["处理第1个: p元素"]
    G --> H{"key和type匹配?"}
    H -->|是| I["复用: 更新props"]
    H -->|否| J["创建新Fiber"]

    I --> K["oldFiber = oldFiber.sibling (span)"]
    J --> K
    K --> L["处理第2个: div元素"]
    L --> M{"与span的key和type匹配?"}
    M -->|否| N["标记span为删除"]
    N --> O["创建新div Fiber"]

    O --> P["oldFiber = oldFiber.sibling (null)"]
    P --> Q["处理第3个: h1元素"]
    Q --> R["oldFiber为null"]
    R --> S["创建新h1 Fiber"]

    S --> T["建立sibling关系"]
    T --> U["p.sibling = div"]
    U --> V["div.sibling = h1"]
    V --> W["完成reconciliation"]

    style I fill:#c8e6c9,color:#000000
    style N fill:#ffcdd2
    style O fill:#c8e6c9,color:#000000
    style S fill:#c8e6c9,color:#000000
```

### 4. 完整的更新流程时序图

```mermaid
sequenceDiagram
    participant App as 应用层
    participant Reconciler as React Reconciler
    participant WorkLoop as Work Loop
    participant BeginWork as Begin Work
    participant ReconcileChildren as Reconcile Children
    participant CompleteWork as Complete Work

    App->>Reconciler: updateContainer(newElement)
    Reconciler->>Reconciler: 创建Update对象
    Reconciler->>WorkLoop: schedultUpdateOnFiber

    WorkLoop->>WorkLoop: prepareFreshStack
    Note over WorkLoop: 创建workInProgress树

    WorkLoop->>BeginWork: beginWork(HostRoot)
    BeginWork->>BeginWork: 处理updateQueue
    BeginWork-->>WorkLoop: 返回div子节点

    WorkLoop->>BeginWork: beginWork(div)
    BeginWork->>ReconcileChildren: reconcileChildren

    Note over ReconcileChildren: 对比新旧children
    ReconcileChildren->>ReconcileChildren: 处理p标签 - 复用
    ReconcileChildren->>ReconcileChildren: 处理span->div - 替换
    ReconcileChildren->>ReconcileChildren: 处理h1标签 - 新增

    ReconcileChildren-->>BeginWork: 返回新的children链表
    BeginWork-->>WorkLoop: 返回p子节点

    WorkLoop->>BeginWork: beginWork(p)
    BeginWork-->>WorkLoop: 返回文本子节点

    WorkLoop->>WorkLoop: 处理文本节点
    WorkLoop->>CompleteWork: completeUnitOfWork(文本)
    CompleteWork-->>WorkLoop: 回到p节点

    WorkLoop->>CompleteWork: completeUnitOfWork(p)
    CompleteWork-->>WorkLoop: 处理sibling(div)

    WorkLoop->>BeginWork: beginWork(div)
    BeginWork-->>WorkLoop: 返回文本子节点

    WorkLoop->>WorkLoop: 处理文本节点
    WorkLoop->>CompleteWork: completeUnitOfWork(文本)
    CompleteWork-->>WorkLoop: 回到div节点

    WorkLoop->>CompleteWork: completeUnitOfWork(div)
    CompleteWork-->>WorkLoop: 处理sibling(h1)

    WorkLoop->>BeginWork: beginWork(h1)
    BeginWork-->>WorkLoop: 返回文本子节点

    WorkLoop->>WorkLoop: 处理文本节点
    WorkLoop->>CompleteWork: completeUnitOfWork(文本)
    CompleteWork-->>WorkLoop: 回到h1节点

    WorkLoop->>CompleteWork: completeUnitOfWork(h1)
    CompleteWork-->>WorkLoop: 回到父节点div

    WorkLoop->>CompleteWork: completeUnitOfWork(div)
    CompleteWork-->>WorkLoop: 回到HostRoot

    WorkLoop->>CompleteWork: completeUnitOfWork(HostRoot)
    CompleteWork-->>Reconciler: 渲染完成

    Reconciler-->>App: 更新完成
```

### 5. WorkInProgress树构建过程

```mermaid
flowchart TD
    subgraph "Current Tree (更新前)"
        A1["HostRoot"]
        B1["div"]
        C1["p"]
        D1["span"]
        E1["text: 我是p标签"]
        F1["text: 我是span标签"]

        A1 --> B1
        B1 --> C1
        B1 --> D1
        C1 --> E1
        D1 --> F1
    end

    subgraph "WorkInProgress Tree (构建中)"
        A2["HostRoot (复用)"]
        B2["div (复用)"]
        C2["p (复用)"]
        G2["div (新建)"]
        H2["h1 (新建)"]
        E2["text: 我是p标签 (复用)"]
        I2["text: 我是span标签 (移动)"]
        J2["text: 我是h1标签 (新建)"]

        A2 --> B2
        B2 --> C2
        B2 --> G2
        B2 --> H2
        C2 --> E2
        G2 --> I2
        H2 --> J2
    end

    subgraph "副作用标记"
        K["span Fiber: 标记删除"]
        L["div Fiber: 标记新增"]
        M["h1 Fiber: 标记新增"]
    end

    A1 -.alternate.-> A2
    B1 -.alternate.-> B2
    C1 -.alternate.-> C2

    style D1 fill:#ffcdd2
    style G2 fill:#c8e6c9,color:#000000
    style H2 fill:#c8e6c9,color:#000000
    style K fill:#ffcdd2
    style L fill:#c8e6c9,color:#000000
    style M fill:#c8e6c9,color:#000000
```

## 总结

这个更新过程展示了React Reconciler的核心工作原理：

1. **节点复用**：p标签及其文本内容被成功复用
2. **节点替换**：span标签被标记删除，新的div标签被创建
3. **节点新增**：h1标签作为新节点被添加
4. **文本复用**："我是span标签"这个文本节点被从旧的span移动到新的div中

整个过程通过双缓冲机制确保了更新的原子性，通过深度优先遍历确保了所有节点都被正确处理。
